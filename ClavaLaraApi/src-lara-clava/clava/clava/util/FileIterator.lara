import lara.Check;
import lara.Io;
import lara.util.StringSet;

import clava.Clava;

//next() method which returns an object with two properties: value, the next value in the sequence; and done, which is true if the last value in the sequence has already been consumed. If value is present alongside done, it is the iterator's return value.

/**
 * Given a folder, collects sources in that folder, and parses and returns one each time next() is called.
 *
 * Pushes an empty Clava AST, when parsed files are added, at maximum one at any given time.
 */
var FileIterator = function(srcFoldername, sourceExt, headerExt) {
	Check.isDefined(srcFoldername, "srcFoldername");
	
	this.srcFoldername = srcFoldername;

	if(sourceExt === undefined) {
		sourceExt = ["c", "cpp"];
	}
	this.sourceExt = sourceExt;

	if(headerExt === undefined) {
		headerExt = ["h", "hpp"];
	}
	this.headerExt = headerExt;
	
	this.files = [];
	this.currentFile = 0;
	this.isInit = false;
	this.isClosed = false;
	
};

/*
FileIterator.prototype.setSourceExtensions = function() {
	return this;
}

FileIterator.prototype.setHeaderExtensions = function() {

	return this;
}
*/

FileIterator.prototype.next = function() {

	if(this.isInit === false) {
		this.isInit = true;
		this._init();
	}

	// Check if finished
	if(this.currentFile >= this.files.length) {
		if(!this.isClosed) {
			this.isClosed = true;
			this._close();
		}
		
		return undefined;
	}

	// Next file
	var sourceFile = this.files[this.currentFile];

	debug("FileIterator.next: Processing file " + sourceFile);
	
	// Ensure program tree is empty before adding file
	Clava.getProgram().removeChildren();
	
	Clava.getProgram().addFileFromPath(sourceFile);

	// Rebuild
	Clava.rebuild();

	var $firstChild = Clava.getProgram().firstChild;

	// Increment
	this.currentFile++;
	
	return $firstChild;
}


FileIterator.prototype._init = function() {

	var srcFolder = Io.getPath(Clava.getData().getContextFolder(), this.srcFoldername);

	this._addIncludes(srcFolder, this.headerExt);

	this.files = this._getFiles(srcFolder, this.sourceExt);

	// Sort files
	this.files.sort();

	debug("FileIterator: found " + this.files.length + " files");
	
	// Work on new AST tree
	Clava.pushAst();

}

FileIterator.prototype._close = function() {
	
	// Recover previous AST
	Clava.popAst();

}

/**
 * Attempts to add folders of header files as includes.
 *
 */
FileIterator.prototype._addIncludes = function(srcFolder, headerExt) {

	// TODO: If needed, add a 'nestingLevel' parameter, which includes up to X ancestors for each header,
	// cutting off if ancestors go before srcFolder
	
	// Current user includes
	var data = Clava.getData();
	var userIncludes = data.getUserIncludes();
	debug("FileIterator._addIncludes: User includes before " + userIncludes);

	// Populate initial set with user includes
	var parents = new StringSet();

	for(var userInclude of userIncludes) {
		parents.add(Io.getAbsolutePath(userInclude));
	}
		
	// Get folders of hFiles
	var headerFiles = this._getFiles(srcFolder, headerExt);

	for(var hFile of headerFiles) {
		parents.add(Io.getAbsolutePath(hFile.getParentFile()));
	}

	// Build new value
	var includeFolders = [];
	for(var parent of parents.values()) {
		
		// Converting to File
		includeFolders.push(Io.getPath(parent));
	}
	data.setUserIncludes(includeFolders);
	debug("FileIterator._addIncludes: User includes after " + data.getUserIncludes());

}

FileIterator.prototype._getFiles = function(folder, extensions) {
	var files = [];

	for(var extension of extensions) {
		var sourceFiles = Io.getFiles(folder, "*." + extension, true);
		files = files.concat(sourceFiles);
	}

	return files;
}
