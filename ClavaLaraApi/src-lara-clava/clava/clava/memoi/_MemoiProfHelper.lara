import lara.util.IdGenerator;
import lara.Strings;
import clava.memoi.MemoiUtils;

var _Memoi_FindTargets_Report = {};

/**
 * 		Finds possible targets for memoization. Filters results based
 * 	on the given predicate function (or uses default).
 * */
aspectdef _Memoi_FindTargets

	input filter end
	output targets = [], report end
	
	// initialize report
	_Memoi_FindTargets_Report.paramsNum = 0;
	_Memoi_FindTargets_Report.unsupportedNums = {};
	_Memoi_FindTargets_Report.paramsType = 0;
	_Memoi_FindTargets_Report.returnType = 0;
	_Memoi_FindTargets_Report.unsupportedTypes = {};
	_Memoi_FindTargets_Report.global = 0;
	_Memoi_FindTargets_Report.calls = 0;

	// use default predicate if user doesn't provide one
	if(filter === undefined) {
		filter = _isValidMemoi;
	}
	
	var processed = {};
	
	select stmt.call end
	apply
		var $func = $call.function;
		if($func === undefined) {
			continue;
		}
		var sig = MemoiUtils.normalizeSig($func.signature);

		// if we've processed this one before (valid or not), skip
		if(_isProcessed(sig, processed)) {
			
			continue;
		}
		
		// test if valid
		var valid = filter($call, processed);
		if(valid === _Res.VALID) {
			var isUser = !MemoiUtils.isWhiteListed(sig); // it's a user function if it's not a whitelisted function
			var target = new MemoiTarget(sig, $func, isUser);
			targets.push(target);
		}
	end
	
	report = _Memoi_FindTargets_Report;
end


/**
 * 		Makes a single global wrapper for all calls of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_GlobalWrapper
	input
		targetSig, normalizedSig, wrapperName, monitorType, monitorName,
		id, reportDir, outputTypes, inputTypes, memoiprofOptions
	end
	
	// make the wrapper
	select stmt.call end
	apply
		var sig = $call.signature;
		sig = Strings.replacer(sig, ' ', '');
		if(sig != targetSig) {
			continue;
		}
		
		exec wrap(wrapperName);
	end
	
	// instrument the wrapper
	call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType, inputTypes.length, outputTypes.length);
	
	// setup
	call _Memoi_Setup(monitorName, monitorType, targetSig, id, reportDir,  outputTypes, inputTypes, ['global'], memoiprofOptions);
end

/**
 * 		Makes an individual wrapper for each call of the target
 * 	function.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_IndividualWrapper
	input
		targetSig, normalizedSig, wrapperNameBase, monitorType,	monitorNameBase,
		idBase, reportDir, outputTypes, inputTypes, memoiprofOptions
	end
	
	select file.stmt.call end
	apply
		
		var sig = $call.signature;
		sig = Strings.replacer(sig, / /g, '');
		if(sig != targetSig) {
			continue;
		}
		
		// make the wrapper
		var wrapperName = IdGenerator.next(wrapperNameBase);
		exec wrap(wrapperName);
					
		// instrument the wrapper
		var monitorName = IdGenerator.next(monitorNameBase);
		call _Memoi_InstrumentWrapper(wrapperName, monitorName, monitorType, inputTypes.length, outputTypes.length);
		
		// make call site info
		//~ var callSiteInfo = $file.name + ':' + $call.line + ':' + $call.column;
		var callSiteInfo = $call.location;
		
		// setup
		var id = IdGenerator.next(idBase + '_');
		call _Memoi_Setup(monitorName, monitorType, targetSig, id, reportDir,  outputTypes, inputTypes, [callSiteInfo], memoiprofOptions);
	end
end

/**
 * 		Instruments a single wrapper with the calls to the memoization profiling
 * library. Adds declaration to the monitor. Also adds the needed header include
 * to the file.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_InstrumentWrapper
	input
		wrapperName,
		monitorName,
		monitorType,
		numInputs,
		numOutputs
	end
	
	select file.function{wrapperName}.stmt.call end
	apply
		var code = 'mp_inc(' + monitorName;
		
		var $params = $function.params;
		
		for(var i = 0; i < numInputs; i++) {
			code += ", &" + $params[i].name;
		}
		
		if(numOutputs == 1) {
		
			code += ', &result';
		} else {
		
			for(var o = numInputs; o < $params.length; o++) {
				code += ", " + $params[o].name;
			}
		}
				
		code += ');';
		
		insert after code;
		insert after "#pragma omp critical"; // needed for correct semantics under OpenMP
		
		$file.exec addGlobal(monitorName, monitorType, 'NULL');
		
		$file.exec addInclude("MemoiProfiler.h", false);
		$file.exec addInclude('stdlib.h', true);
	end
end

/**
 * 		Performs the setup needed for the instrumentation with the
 * 	memoization profiling library in the main file. This includes
 * 	declaring and initializing the monitor, printing the report, and
 * 	destroying the monitor.
 * 
 * @aspect
 * @private
 * */
aspectdef _Memoi_Setup

	input
		monitorName,
		monitorType,
		targetSig,
		id,
		dir,
		outputTypes, inputTypes,
		callSiteInfo,
		memoiprofOptions
	end

	var inputsCode = inputTypes.map(function(e){return "mp_" + e;}).join(',').toUpperCase();
	var outputsCode = outputTypes.map(function(e){return "mp_" + e;}).join(',').toUpperCase();

	var mainFound = false;

	select file.function{'main'}.body end
	apply
	
		mainFound = true;
		
		var memoiReportPath = "path_" + monitorName;
		
		// memoiprof options
		if(memoiprofOptions.samplingKind !== "off") {
			var samplingKind = "MP_SAMPLING_" + memoiprofOptions.samplingKind.toUpper();
			$body.exec insertBegin(%{mp_set_sampling([[monitorName]], [[samplingKind]], [[memoiprofOptions.samplingRate]]);}%);
		}
		
		if(memoiprofOptions.periodicReportKind) {
			$body.exec insertBegin(%{mp_set_periodic_reporting([[monitorName]], "MP_PERIODIC_ON", [[memoiprofOptions.periodicReportRate]]);}%);
		}
		
		if(memoiprofOptions.cullingKind) {
			$body.exec insertBegin(%{mp_set_culling([[monitorName]], "MP_CULLING_ON", [[memoiprofOptions.cullingRatio]]);}%);
		}
		
		if(memoiprofOptions.approxKind) {
			$body.exec insertBegin(%{mp_set_approx([[monitorName]], "MP_APPROX_ON", [[memoiprofOptions.approxBits]]);}%);
		}
		
		call _Memoi_AddCallSiteInfo($body, callSiteInfo, monitorName);
		$body.exec insertBegin(%{free([[memoiReportPath]]);}%); // can free here, since mp_init duped it
		$body.exec insertBegin(%{[[monitorName]] = mp_init("[[targetSig]]", "[[id]]", [[memoiReportPath]], [[inputTypes.length]], [[outputTypes.length]], [[inputsCode]], [[outputsCode]]);}%);
		$body.exec insertBegin(%{char* [[memoiReportPath]] = mp_make_report_path("[[dir]]", "[[monitorName]]");}%);
		
		/* add functions to print and clean up at every return on main */
		$function.exec insertReturn(%{mp_to_json([[monitorName]]);}%);
		$function.exec insertReturn(%{[[monitorName]] = mp_destroy([[monitorName]]);}%);
		

		$file.exec addGlobal(monitorName, monitorType, 'NULL');

		$file.exec addInclude('MemoiProfiler.h', false);
		$file.exec addInclude('stdlib.h', true);
	end
	
	checkTrue(mainFound, 'Could not find main function needed for setup', 'MemoiProf');
end

aspectdef _Memoi_AddCallSiteInfo
	input $mainBody, callSiteInfo, monitorName end
	
	// call site info
	if(callSiteInfo === undefined) {
		callSiteInfo = ['global'];
	}
	
	checkArray(callSiteInfo);
	
	var length = callSiteInfo.length;
	var code = 'mp_set_call_sites(' + monitorName + ', ' + length ;
	for(var i of callSiteInfo) {
		code += ', "' + i + '"';
	}
	code += ');';
	
	$mainBody.exec insertBegin(code);
end






