/**
 * Instruments an application so that it counts total operations in a region of code.
 *
 */
var OpsCounter = function() {
	this._counters = {};
	this._$counterType = ClavaJoinPoints.builtinType("long");
};

// Whitelist of ops
OpsCounter._validOps = new StringSet("mul", "div", "rem", "add", "sub", "shl", "shr", "cmp", "and", "xor", "or", "l_and", "l_or", "mul_assign", "div_assign", "rem_assign", "add_assign", "sub_assign", "shl_assign", "shr_assign", "and_assign", "xor_assign", "or_assign", "post_inc", "post_dec", "pre_inc", "pre_dec");


OpsCounter.prototype.instrument = function($region) {
	// Apply to all ops found in the region
	for(var $op of Query.searchFrom($region, 'op')) {
		this._countOp($op);
	}
	
	// TODO: Call function recursively when function calls are found
};


OpsCounter.prototype._countOp = function($op) {

	// If not a valid op, return
	if(!OpsCounter._isValidOp($op)) {
		return;
	}
	
	println("Op ("+$op.kind+"): " + $op.code);

	// Always add to ops counter
	var opsCounter = this._getCounter("ops", "");
	var opsCounterStmt = ClavaJoinPoints.stmtLiteral(opsCounter.getRef($op).code + "++;");
	$op.insertBefore(opsCounterStmt);			
		
	// Calculate type and bitwidth
	var $builtinType = this._toBuiltinType($op.type);
	var counterType = this._getCounterType($builtinType);
	var bitwidth = $builtinType !== undefined ? $builtinType.bitWidth($op) : undefined;

	// Get counter
	var counter = this._getCounter(counterType, bitwidth);		
		
	// Add to corresponding counter type	
	var counterStmt = ClavaJoinPoints.stmtLiteral(counter.getRef($op).code + "++;");
	$op.insertBefore(counterStmt);
}


OpsCounter.prototype._getCounter = function(counterType, bitwidth) {
	var counterName = this._getCounterPrefix(counterType, bitwidth) + "_counter";
	
	// Check if counter exists 
	var counter = this._counters[counterName];
	
	if(counter === undefined) {
		counter = new GlobalVariable(counterName, this._$counterType, "0");
		this._counters[counterName] = counter;
	}
	
	return counter;
}

OpsCounter.prototype._getCounterPrefix = function(counterType, bitwidth) {

	// If counterType is undefined, return unknown, without looking at the bitwidth
	if(counterType === undefined) {
		return "unknown";
	}
	
	var counterPrefix = counterType;

	var bitwidthString = bitwidth !== undefined ? bitwidth.toString() : "unknown";
	
	if(!Strings.isEmpty(bitwidthString)) {
	counterPrefix += "_";
	}
	
	counterPrefix += bitwidthString;

	return counterPrefix;
}

OpsCounter.prototype._getCounterType = function($builtinType) {
	
	if($builtinType === undefined) {
		return undefined;
	}
	
	if($builtinType.isFloat) {
		return "flops";
	} else if($builtinType.isInteger) {
		return "iops";
	} else {
		PrintOnce.message("OpsCounter: could not determine if builtinType " + $type.kind + " is integer or float");
		return undefined;	
	}
}

OpsCounter.prototype._toBuiltinType = function($type) {
	if($type.instanceOf("builtinType")) {
		return $type;
	}
	
	PrintOnce.message("OpsCounter: could not determine builtinType of " + $type.joinPointType);
	return undefined;
}

/**
 * Adds code that prints the operation counting report.
 */
OpsCounter.prototype.log = function($insertionPoint) {

		var logger = new Logger();		
		for(counterName in this._counters) {	
			var counter = this._counters[counterName];
			logger.text(counterName + ": ").long(counter.getRef($insertionPoint).code).ln();
		}

		logger.log($insertionPoint);
};



OpsCounter._isValidOp = function($op) {
	var isValid = OpsCounter._validOps.has($op.kind);
	
	if(!isValid) {
		return false;
	}
	
	// Ignore operations inside loop headers
	if($op.isInsideLoopHeader) {
		return false;
	}
	
	return true;
}